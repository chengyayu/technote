# 数组

## 数组的定义

数组是一种 **线性表（linear list）** 数据结构，它用一组 **连续的内存空间** 存储一组具有 **相同类型** 的数据。

「连续的内存空间」和「相同类型的数据」这两个限制，决定数组有了一个重要的特性：**随机访问**。不过它们也让数组的 **插入和删除操作变得非常低效**，为了保证数组中存储数据的连续性，我们需要做大量的数据搬移工作。

## 内部存储结构

数组需要连续的内存空间来存储数据，假设我们创建一个数组需要申请 100MB 大小的内存空间，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。

## 随机访问

「随机访问」具体指的是：支持在 `O(1)` 时间复杂度内按照下标快速访问数组中的元素。

假设计算机给数组 a[10] 分配了一块连续内存空间，首地址 `base_address = 1000`。当计算机想要访问下标为 i 的数组元素时，它首先通过下面的 **寻址公式** 计算出该元素存储的内存地址，然后根据地址访问对应的内存单元。

```go
// 寻址公式
a[i]_address = base_address + i * data_type_size
```

其中，`data_type_size` 表示数组中每个元素的大小。

## 插入操作

假设数组长度为 n。我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，需要将第 k~n 这部分元素顺序地往后移动一位。平均时间复杂度为：`(1+2+...+n)/n = O(n)`。

如果数组中的数据是有序的，上述情况只能如此搬移。但是，如果数组中存储的数据无序，它仅作为一个存储数据的集合使用。为了避免大规模的数据搬移，我们可以将第 k 位的数据搬移到数组的最后，然后把新数据直接放到第 k 个位置即可。此时在第 k 个位置插入一个元素的时间复杂度为：`O(1)`。

## 删除操作

与插入操作类似，如果我们要删除第 k 个位置的数据，为了存储的连续性也需要搬移数据。不然中间就会存在已经删除的数据，违背了数据的连续性。

- 最好时间复杂度：`O(1)` 删除数据尾部数据 
- 最坏时间复杂度：`O(n)` 删除数组开头数据
- 平均时间复杂度：`O(n)` 删除任意位置数据

事实上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多。

假设数组 a[10] 中存储了8个元素，[a,b,c,d,e,f,g,h]。现在我们要依次删除 a、b、c，为了避免 d~h 这几个元素被搬移3次，每次的删除操作仅 **标记** 数据已删除。当数组中没有更多的存储空间时，**集中触发执行一次真正的删除操作**。这样就大大减少了删除操作导致的数据搬移次数。这也是 JVM 标记清除 gc 算法的核心思想。

## 警惕数组访问越界问题

```go
a := [2]int{1, 2}

for i := 0; i <= 2; i++ {
	fmt.Println(a[i])
}
```

Go 语言中，数组访问越界会导致 panic。

```shell
panic: runtime error: index out of range [2] with length 2
```

## 各项操作时间复杂度

| 操作 | 时间复杂度 | 备注 |
| --- | --- | ---|
| prepend | O(1) | 通过头部预留空间的方式可以把原本 O(n) 复杂度的 prepend 操作优化到 O(1) |
| append | O(1) ||
| lookup | O(1) |准确的说是根据下标访问元素的时间复杂度为 O(1)|
| insert | O(n) |低效，涉及元素搬移|
| delete | O(n) |低效，涉及元素搬移|