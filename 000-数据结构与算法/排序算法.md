# 排序算法

## 算法概述

对于排序算法，除学习**算法原理**、**代码实现**之外，更重要的是学习每个算法的**特点**，知道它们的**最佳应用场景**。

对于排序算法的执行效率评估，一般从以下几个方面分析。

**1、最好时间复杂度、最坏时间复杂度和平均时间复杂度。**

对于排序算法，原始数据的有序度（接近有序的程度）对排序的时间会有比较大的影响。

**2、时间复杂度的系数、常数和低阶。**

大 O 表示法表示复杂度时，我们常常会忽略系数、常数和低阶。但在实际开发中，要排序的数据规模可能比较小，在对时间复杂度相同的排序算法进行性能比较时，可以把系数、常数和低阶考虑进来。

**3、比较次数和交换次数。**

对于基于比较的排序算法，进行精细化分析时，由于比较操作的耗时少于交换操作的耗时，可以把比较次数和交换次数区分开来统计。

**4、空间消耗**

- **原地排序**：在原数据存储空间上完成排序操作。
- **非原地排序**：需要额外的非常量级的数据存储空间才能完成排序。

**5、稳定性**

- **稳定**：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面。
- **不稳定**：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面。



### 分类

- 比较类排序
    - 交换排序
        - 冒泡排序
        - `快速排序`
    - 插入排序
        - 简单插入排序
        - 希尔排序
    - 选择排序
        - 简单选择排序
        - `堆排序`
    - `归并排序`
        - 二路归并排序
        - 多路归并排序
- 非比较类排序
    - 计数排序
    - 桶排序
    - 基数排序

### 复杂度 

![排序算法时空复杂度](./static/sort_time_space_complexity.png)

## 快速排序

算法描述：如果要排序数据序列中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点），假设对应下标是 q。

遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数据序列 [p,r] 之间的数据就被分成了三个部分，[p,q-1] 之间都是小于 pivot 的，中间是 pivot，[q+1,r] 之间是大于 pivot 的。

![快排-分区操作](./static/quick_sort.png)

递归出处理 [p,q-1] 与 [q+1,r] 两部分，终止条件时 p >= r。

```go
func QuickSort(nums []int, p int, r int) {
    // 递归终止条件
    if p >= r {
        return
    }
    q := partition(nums, p, r)
    QuickSort(nums, p, q - 1)
    QuickSort(nums, q + 1, r)
}

// 分区操作，确定分区点位置
func partition(nums []int, p int, r int) int {
    pivot := nums[r]
    // i 标记 q+1
    i := p
    for j := p; j < r; j++ {
        if nums[j] < pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }

    // i 位置的值与q位置的值交换
    nums[i], nums[r] = pivot, nums[i]
    
    // 返回 i 作为 pivot 分区位置
    return i
}
```








## 冒泡排序

算法描述：数组中前一个元素和后一个元素进行比较如果大于（或者小于）前者就进行交换，最终返回最大（或者最小）都“冒”到数组的最后。

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

```go
func BubbleSort(arr []int) []int {
	for i := 0; i < len(arr)-1; i++ {
		for j := i + 1; j < len(arr); j++ {
			if arr[i] > arr[j] {
				arr[i], arr[j] = arr[j], arr[i]
			}
		}
	}
	return arr
}
```

## 插入排序

算法描述：将待排数组氛围两个区间，**已排区间**和**未排区间**。初始已排区间只有一个元素，即数组第一个元素。取未排区间中的元素，在已排区间中找到合适位置将其插入，并保证已排区间数据一直有序。重复该过程，直到未排区间中的元素为空。

- 时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定性：稳定

```go
func InsertionSort(arr []int) []int {
	if len(arr) == 1 {
		return arr
	}
	for i := 1; i < len(arr); i++ {
		v := arr[i]
		j := i - 1
		for ; j >= 0; j-- {
			if v < arr[j] {
				arr[j+1] = arr[j]
			} else {
				break
			}
		}
		arr[j+1] = v
	}
	return arr
}
```



## 参考资料
- [十大经典排序算法](https://www.cnblogs.com/onepixel/p/7674659.html)